# Running Sum of 1D Array (LeetCode 1480)

## คำอธิบายปัญหา
ให้อาร์เรย์ของตัวเลข `nums` จงคืนค่าอาร์เรย์ใหม่ที่แต่ละตำแหน่ง `i` มีค่าเท่ากับผลรวมของอาร์เรย์ `nums` ตั้งแต่ตำแหน่งที่ 0 ถึง i

**ตัวอย่าง**
```
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
คำอธิบาย: Running sum คือ [1, 1+2, 1+2+3, 1+2+3+4]
```

## วิธีคิดแบบละเอียด

### 1. การวิเคราะห์ปัญหา
- **อินพุต**: อาร์เรย์ของจำนวนเต็ม `nums` โดยที่ `1 <= nums.length <= 1000` และ `-10^6 <= nums[i] <= 10^6`
- **เอาต์พุต**: อาร์เรย์ของจำนวนเต็มที่มีความยาวเท่ากับ `nums`

### 2. วิธีคิดแบบ Brute Force
สำหรับแต่ละตำแหน่ง i ในผลลัพธ์:
1. เริ่มต้นผลรวมเป็น 0
2. วนลูปจากตำแหน่ง 0 ถึง i
3. บวกค่าทั้งหมดเข้าด้วยกัน

**ความซับซ้อน**:
- เวลา: O(n²) เนื่องจากมีลูปซ้อนกัน
- พื้นที่: O(n) สำหรับเก็บผลลัพธ์

### 3. วิธีคิดแบบ Dynamic Programming
ใช้ประโยชน์จากผลลัพธ์ที่คำนวณไปแล้ว:
1. สร้างอาร์เรย์ผลลัพธ์ที่มีขนาดเท่ากับอินพุต
2. กำหนดให้ผลลัพธ์ตำแหน่งแรกเท่ากับค่าตำแหน่งแรกของอินพุต
3. สำหรับแต่ละตำแหน่ง i ตั้งแต่ 1 ถึง n-1:
   - ผลลัพธ์[i] = ผลลัพธ์[i-1] + อินพุต[i]

**ความซับซ้อน**:
- เวลา: O(n) เนื่องจากวนลูปเพียงครั้งเดียว
- พื้นที่: O(n) สำหรับเก็บผลลัพธ์

### 4. การพิสูจน์ความถูกต้อง
พิจารณาอินพุต `[a, b, c, d]`:
- ผลลัพธ์[0] = a
- ผลลัพธ์[1] = a + b = ผลลัพธ์[0] + b
- ผลลัพธ์[2] = a + b + c = ผลลัพธ์[1] + c
- ผลลัพธ์[3] = a + b + c + d = ผลลัพธ์[2] + d

## การนำไปใช้จริง
1. **การเงิน**: คำนวณยอดสะสมรายวัน/รายเดือน
2. **สถิติ**: คำนวณค่าเฉลี่ยเคลื่อนที่
3. **การประมวลผลสัญญาณ**: คำนวณผลรวมสะสมของสัญญาณ

## ตัวอย่างการทำงาน
### ตัวอย่างที่ 1
**อินพุต**: `[1, 1, 1, 1, 1]`  
**กระบวนการทำงาน**:
1. ผลลัพธ์ = [1, 0, 0, 0, 0]
2. i=1: [1, 1+1=2, 0, 0, 0]
3. i=2: [1, 2, 2+1=3, 0, 0]
4. i=3: [1, 2, 3, 3+1=4, 0]
5. i=4: [1, 2, 3, 4, 4+1=5]
**ผลลัพธ์**: `[1, 2, 3, 4, 5]`

### ตัวอย่างที่ 2
**อินพุต**: `[3, 1, 2, 10, 1]`  
**กระบวนการทำงาน**:
1. ผลลัพธ์ = [3, 0, 0, 0, 0]
2. i=1: [3, 3+1=4, 0, 0, 0]
3. i=2: [3, 4, 4+2=6, 0, 0]
4. i=3: [3, 4, 6, 6+10=16, 0]
5. i=4: [3, 4, 6, 16, 16+1=17]
**ผลลัพธ์**: `[3, 4, 6, 16, 17]`

## การทดสอบ
รันคำสั่งต่อไปนี้เพื่อทดสอบ:
```bash
# ทดสอบทั้งหมด
make test-all

# ทดสอบเฉพาะปัญหานี้
make test-1480
```

## ข้อสังเกตเพิ่มเติม
1. **Edge Cases**:
   - อาร์เรย์ว่างเปล่า: คืนค่าอาร์เรย์ว่าง
   - อาร์เรย์มีสมาชิก 1 ตัว: คืนค่าเดิม
   - ตัวเลขติดลบ: ทำงานได้ปกติ

2. **การปรับปรุงประสิทธิภาพ**:
   - สามารถลดการใช้พื้นที่เป็น O(1) โดยแก้ไขอาร์เรย์เดิมได้ (ถ้าอนุญาต)
   - ใช้ goroutine แบ่งงานสำหรับอาร์เรย์ขนาดใหญ่มากๆ

3. **ทางเลือกอื่น**:
   - ใช้ฟังก์ชัน `append` แทนการกำหนดค่าโดยตรง
   - ใช้ `copy` เพื่อป้องกันการแก้ไขอาร์เรย์ต้นฉบับ

## อ้างอิง
- [LeetCode Problem 1480](https://leetcode.com/problems/running-sum-of-1d-array/)
